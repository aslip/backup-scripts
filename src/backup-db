#!/bin/bash


set -e

usage() {
    cat << EOF
makes full or incremental database backup

usage:
    ${0##*/} DB USER PASS DATE PREV_DATE [XTRA_OPT]

use "-" to indicate an empty PASS;
use "-" instead of PREV_DATE to make a full backup, 
otherwise incremental backup is made;

full backup is a mysql dump
incremental backup is made by diff-ing two sibling dumps
EOF
    exit 1
}

DB=$1
USER=$2
PASS=$3
DATE=$4
PREV_DATE=$5
XTRA_OPT=$6

if [[ -z $DB || -z $USER || -z $PASS || -z $DATE || -z $PREV_DATE ]]; then
    usage
fi

# contains dump_to $DST function, it is shared to help in testing
. ./backup-dump

. ./backup-options

if [[ $PREV_DATE != - ]]; then
    IS_INCR=1
fi

mkdir -p $TMP_DIR/$DATE/db      # this is what will be copied to backup server
mkdir -p $TMP_DIR/.sql/$DATE    # this is temporary that is needed for incremental backups

if [[ ! $IS_INCR ]]; then
    # full backup
    TMP_DUMP=$TMP_DIR/.sql/$DATE/$DB.sql
    DUMP=$TMP_DIR/$DATE/db/$DB.sql.bz2

    dump_to $TMP_DUMP
    # keep the .sql dump in temporary folder for possible 
    # incremental backups;
    # compress to stdout
    bzip2 -kc $TMP_DUMP > $DUMP
else
    # incremental backup

    INCR_OLD=$TMP_DIR/.sql/$PREV_DATE/$DB.sql
    INCR_NEW=$TMP_DIR/.sql/$DATE/$DB.sql
    DUMP=$TMP_DIR/$DATE/db/$DB.sql.inc

    dump_to $INCR_NEW

    # create an edit script
    set +e # diff may return 1 on success: 0 means no differences, 1 means some, 2 means error
    diff -e --speed-large-files $INCR_OLD $INCR_NEW > $DUMP
    if (($? == 2)); then
        exit 1
    fi
    set -e
    echo -e "w\nq" >> $DUMP

    # compress it
    bzip2 $DUMP # we can't make anything useful with an incremental db backup, so don't keep it uncompressed

    # we don't need the old dump anymore, but note that we kept the new one
    rm $INCR_OLD
fi

