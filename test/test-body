# vim: set ft=sh:

. colors
 
test_print() {
    echo -e "${C_BWHITE}$1${C_RESET}"
}

test_begin() {
    TEST_CURRENT=$1 # global
    test_print "$TEST_CURRENT..."
}

test_end() {
    test_print "$TEST_CURRENT - ${C_BGREEN}OK"
    echo -e "\n\n"
}

cleanup() {
    test_print 'cleanup...'

    if [[ -e './tmp' ]]; then
        rm -r './tmp'
    fi
    if [[ -e "./$TEST_FILES_DIR" ]]; then
        rm -r "./$TEST_FILES_DIR"
    fi
    if [[ -e $TEST_SERVER_PATH ]]; then
        rm -r "$TEST_SERVER_PATH"
    fi
    if [[ -e "./$TEST_BACKUP_DIR" ]]; then
        rm -r "./$TEST_BACKUP_DIR"
    fi
    $MYSQL -e "DROP DATABASE IF EXISTS $TEST_DB"
    $MYSQL -e "CREATE DATABASE $TEST_DB DEFAULT CHARSET utf8"
}

cleanup

use_files() {
    local files_to_use=$1
    rm -rf "./$TEST_FILES_DIR"
    # follow command line symlinks (since ./$TEST_DATA_DIR/$files_to_use
    # may be a symlink); any symbolic link that is encountered via 
    # recursive traversal will be copied as is
    cp -aH "./$TEST_DATA_DIR/$files_to_use" "./$TEST_FILES_DIR"
}

use_db() {
    local sql_to_use=$1
    cat "./$TEST_DATA_DIR/$sql_to_use" | $MYSQL "$TEST_DB"
}

restore_files() {
    local date=$1
    local archive=$2 # e.g. "test" or "test.inc"
    # don't produce error only when there is already a "restored-files" dir
    # this is different from "mkdir -p", because it will fail when e.g. "tmp" does not exist
    if [[ ! -e './tmp/restored-files' ]]; then
        mkdir './tmp/restored-files'
    fi
    if [[ $UID != 0 ]]; then
        local dar_opt=-O # ignore owner (owner can be restored only under root)
    fi
    # -w means "don't warn when overwriting files" and it must be there 
    # if we are simply restoring an archive
    dar $dar_opt -w -x "$TEST_SERVER_PATH/$date/files/$archive" -R './tmp/restored-files'
}

check_files() {
    local reference_files=$1
    diff -r './tmp/restored-files' "./$TEST_DATA_DIR/$reference_files"
    # keep the restored-files dir for incremental restores
}

restore_db() {
    local date=$1
    bunzip2 -kc "$TEST_SERVER_PATH/$date/db/$TEST_DB.sql.bz2" > './tmp/restored-db.sql'
    cat './tmp/restored-db.sql' | $MYSQL "$TEST_DB"
    # keep the restored-db.sql for incremental restores
}

restore_db_incr() {
    local date=$1
    bunzip2 -kc "$TEST_SERVER_PATH/$date/db/$TEST_DB.sql.inc.bz2" > './tmp/sql.inc'
    # suppress diagnostics (ed's man requires this when ed's stdin is from script)
    ed -s './tmp/restored-db.sql' < './tmp/sql.inc'
    rm './tmp/sql.inc'
    cat './tmp/restored-db.sql' | $MYSQL "$TEST_DB"
}

. "`backup-include mysql`" # for backup_mysql_dump

check_db() {
    local reference_sql=$1
    backup_mysql_dump "$TEST_DB" "$TEST_USER" "$TEST_PASS" "$TEST_EXCLUDE_TABLES" '' './restored.sql'
    diff './restored.sql' "./$TEST_DATA_DIR/$reference_sql"
    rm './restored.sql'
}

check_ignore_tables() {
    # FIXME: does not work
    grep -vi 'table2' './tmp/restored-db.sql' > /dev/null
    grep -vi 'table3' './tmp/restored-db.sql' > /dev/null
}

DATE0=`date -d '+0 days' -I`
DATE1=`date -d '+1 days' -I`
DATE2=`date -d '+2 days' -I`

mkdir "$TEST_SERVER_PATH"
mkdir './tmp'

test_end # initializing



test_begin 'making full backup'
    use_files 'test.0'
    use_db 'backup_test.0.sql'
    BACKUP_DATE="$DATE0" test-backup
test_end

test_begin 'making incremental backup against a full backup'
    use_files 'test.1'
    use_db 'backup_test.1.sql'
    BACKUP_DATE="$DATE1" test-backup --incremental
test_end

test_begin 'making incremental backup against an incremental backup'
    use_files 'test.2'
    use_db 'backup_test.2.sql'
    BACKUP_DATE="$DATE2" test-backup --incremental
test_end




test_begin 'checking full backup files'
    restore_files "$DATE0" "$TEST_FILES_ALIAS"
    check_files 'test.0'
test_end
test_begin 'checking full backup db'
    restore_db "$DATE0"
    check_db 'reference.0.sql'
test_end
test_begin 'checking full backup ignore-tables'
    check_ignore_tables
test_end



test_begin 'checking 1st incremental backup files'
    restore_files "$DATE1" "$TEST_FILES_ALIAS.inc"
    check_files 'test.1'
test_end
test_begin 'checking 1st incremental backup db'
    restore_db_incr "$DATE1"
    check_db 'reference.1.sql'
test_end
test_begin 'checking 1st incremental backup ignore-tables'
    check_ignore_tables
test_end


test_begin 'checking 2nd incremental backup files'
    restore_files "$DATE2" "$TEST_FILES_ALIAS.inc"
    check_files 'test.2'
test_end
test_begin 'checking 2nd incremental backup db'
    restore_db_incr "$DATE2"
    check_db 'reference.2.sql'
test_end
test_begin 'checking 2nd incremental backup ignore-tables'
    check_ignore_tables
test_end

cleanup

